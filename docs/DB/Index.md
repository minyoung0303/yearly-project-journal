# Index

## 📘 DB Index 면접 질문 & 모범 답변

### 1. 인덱스가 무엇인가요? 왜 사용하나요?

답변:

인덱스는 데이터베이스에서 원하는 데이터를 빠르게 조회하기 위한 자료구조입니다.
일반적으로 B+ Tree 혹은 Hash Index가 사용되며, 데이터를 정렬된 상태로 유지해서 조회 성능을 크게 향상시킵니다.
대신 INSERT/UPDATE/DELETE 시에는 인덱스도 갱신해야 해서 추가 비용이 발생합니다.
즉, 읽기 성능을 개선하는 대신 쓰기 비용이 증가하는 구조입니다.

### 2. 인덱스를 사용하면 무조건 성능이 좋아지나요?

답변:

아닙니다. 조회에는 도움이 되지만,

데이터 변경(Write) 비용 증가

과도한 인덱스 생성 시 메모리/디스크 낭비

쿼리 최적화가 인덱스를 잘 활용하지 못할 가능성

등의 문제가 발생할 수 있습니다. **테이블의 특성, 데이터량, 조회 패턴**에 따라 선택적으로 인덱스를 설계해야 합니다.

### 3. B-Tree 인덱스는 어떤 방식으로 탐색이 이루어지나요?

답변:

B+Tree 인덱스는 루트 → 중간 노드 → 리프 노드 순으로 내려가며 키 값을 비교해 탐색합니다.
리프 노드는 정렬된 연결 리스트 형태로 저장되어 있어 범위 검색이 효율적입니다.
탐색 시간은 일반적으로 **O(logN)**입니다.

### 4. 해시(Hash) 인덱스와 B-Tree 인덱스의 차이점은?

답변:

구분 B+ Tree Index Hash Index
구조 트리 구조 해시 테이블
조회 범위 검색, 정렬 지원 정확한 값 조회(=)에 최적
장점 범위 검색 빠름 정확한 매칭 빠름
단점 동등 조회는 Hash보다 느림 범위 검색 불가능

범위 검색이 필요한 경우 → B-Tree
정확한 키 매칭만 필요한 경우 → Hash

### 5. 인덱스를 걸면 안 되는 컬럼의 특징은?

답변:

카디널리티가 낮은 컬럼 (예: 성별, boolean 등)

자주 업데이트되는 컬럼

테이블의 데이터가 매우 적은 경우

연산이 자주 사용되는 컬럼 (예: LEFT(name, 3), age + 1)

LIKE "%abc" 와 같이 앞부분이 wildcard(%) 인 패턴 검색

### 6. Composite Index(복합 인덱스)의 Leftmost Rule이 무엇인가요?

답변:

복합 인덱스는 왼쪽에서부터 차례대로 컬럼을 사용할 때만 인덱스가 제대로 적용되는 규칙입니다.

예: (A, B, C) 인덱스가 있을 때
사용 가능한 조합은

A

A, B

A, B, C

이며 B, C, 또는 (B, C) 만 사용하는 쿼리는 인덱스를 타지 않습니다.

### 7. 인덱스를 탄다/안 탄다를 어떻게 판단하나요?

답변:

DB에서 EXPLAIN 또는 EXPLAIN ANALYZE 로 실행 계획을 확인합니다.
중요 지표는 다음과 같습니다:

type: index 사용 여부 (index, ref, range 등)

possible_keys: 후보 인덱스

key: 실제 사용한 인덱스

rows: 예측 스캔 개수

Extra: “Using index”, “Using where”, “Using filesort” 등

이 정보를 통해 쿼리가 어떤 방식으로 인덱스를 활용하는지 분석할 수 있습니다.

### 8. covering index(커버링 인덱스)란?

답변:

쿼리가 필요한 모든 컬럼이 인덱스에만 존재해 테이블을 읽을 필요가 없는 인덱스만의 조회 방식입니다.
이 방식은 디스크 IO를 획기적으로 줄여 조회 성능을 크게 향상합니다.

예시:
인덱스 (name, age) 가 있고,
SELECT name, age FROM user WHERE name='A'
→ 테이블 접근 없이 인덱스만으로 처리 가능 → covering index

### 9. 인덱스가 잘 작동하지 않는 쿼리 패턴은?

답변:

%keyword 와 같은 전방 Wildcard

컬럼을 함수 처리한 경우

데이터 타입이 맞지 않는 비교

OR 조건이 많은 경우

NOT 조건

매우 작은 테이블(full scan이 더 빠름)

### 10. 인덱스가 너무 많으면 어떤 문제가 생기나요?

답변:

INSERT/UPDATE/DELETE 시 성능 저하

추가적인 저장 공간 필요

옵티마이저가 인덱스를 잘못 선택할 가능성 증가

유지보수 복잡도 증가

보통 실무에서는 조회 패턴 기준 최소한의 인덱스만 생성하는 것이 좋습니다.

### 11. Clustered Index와 Non-clustered Index의 차이는?

(MySQL InnoDB 기준)

답변:

Clustered Index

PK 기반

실제 데이터가 B+Tree 리프 노드에 정렬된 형태로 저장

테이블 전체가 인덱스 자체

Non-clustered Index

보조 인덱스

리프 노드에는 실제 데이터가 아니라 PK 값을 저장

조회 시 PK 기반으로 다시 테이블 접근이 발생할 수 있음 (Double Lookup)

### 12. 인덱스 스캔(Index Scan)과 인덱스 시크(Index Seek)의 차이는?

답변:

Index Seek: 정확한 값 또는 범위 조건으로 인덱스를 빠르게 탐색 (효율적)

Index Scan: 인덱스를 전체 순회하면서 조건에 맞는 레코드 찾기 (비효율적)

Seek이 훨씬 빠르며, DB는 보통 Seek을 사용하게 인덱스 설계를 추천합니다.
